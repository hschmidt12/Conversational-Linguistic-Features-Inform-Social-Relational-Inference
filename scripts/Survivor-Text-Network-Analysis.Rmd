---
title: "Survivor Text & Social Network Analysis"
author: "Helen Schmidt"
date: "`r Sys.Date()`"
output:
  html_document:
    df_print: paged
    theme: cerulean
    toc: true
    toc_float: true
    code_folding: hide
    number_sections: false
---
<style>
h1, h2, h3, h4, h5, h6, legend {
    color: #046C9A;
}
</style>

```{r message=FALSE, warning=FALSE}
library(tidyverse)
library(tidytext)
library(dplyr)
library(knitr)
library(readr)
library(wordcloud)
library(wordcloud2)
library(RColorBrewer)
library(tm)
library(SnowballC)
library(XML)
library(RCurl)
library(ggpubr)
library(wesanderson)
library(reshape2)
library(MetBrewer)
library(sentimentr)
library(sna)
#library(flextable)
library(splitstackshape)
library(GGally)
library(ggraph)
library(gutenbergr)
library(igraph)
library(Matrix)
library(network)
#library(quanteda)
library(tidygraph)
library(tibble)
# activate klippy for copy-to-clipboard button
#klippy::klippy()

```

```{r message=FALSE, warning=FALSE}
# define color palette
colors <- met.brewer("Hiroshige", 10, type = "discrete")
palette <- met.brewer("Hiroshige", 25, type = "continuous")

# load survivor text data
data <- read.csv("survivor-text.csv")

# make sure dialogue is a character vector
data$Dialogue <- as.character(data$Dialogue)

# make speaker, recipient, and recipient type character vectors too
data$Speaker <- as.character(data$Speaker)
data$Recipient <- as.character(data$Recipient)
data$RecipientType <- as.character(data$RecipientType)

# remove space from Shii Ann's name for ease of plotting
data$Speaker[data$Speaker == "Shii Ann"] = "ShiiAnn"
data$Recipient[data$Recipient == "Shii Ann"] = "ShiiAnn"

# make sure recipient type matches recipient
data$RecipientType <- "Person"
data$RecipientType[data$Recipient == "Tribe"] = "Group"
data$RecipientType[data$Recipient == "Camera"] = "Camera"

# remove extra character (restaurant server)
data <- subset(data, data$Recipient != "Server")
```

# Sentiment Analysis 

#### Calculate sentiment score for each sentence

```{r message=FALSE, warning=FALSE}
sentiment(data$Dialogue)
```

#### Calculate mean sentiment score and SD for each chunk of sentences

Mean sentiment score and SD are calculated for all sentences from one speaker to a given recipient at a given time point.

```{r message=FALSE, warning=FALSE}
sentiment_by(data$Dialogue, by = NULL)
```

```{r message=FALSE, warning=FALSE}
# add polarity levels for each sentence
data_with_pol <- data %>% 
  get_sentences() %>% #get each sentence
  sentiment() %>% #get sentiment score
  mutate(polarity_level = ifelse(sentiment < 0, "Negative", #make scores < 0 "negative" and scores > 0 "positive"
                                 ifelse(sentiment > 0, "Positive","Neutral"))) #else, make scores = 0 "neutral"

```

### Overall Sentiment Score

Let's see what each speaker's average sentiment score is!

```{r message=FALSE, warning=FALSE}
ggplot(data_with_pol, aes(x = Speaker, y = sentiment, fill = Speaker)) + 
  stat_summary(fun = mean, geom = "bar", color = "black", alpha = 0.8, position = "dodge") +
    stat_summary(fun.data = mean_se, geom = "errorbar", fun.args = list(mult = 1.96), width = 0.3, color = "black") +
  scale_fill_manual(values = colors) +
  xlab("speaker") + ylab("average sentiment") + 
  theme_classic() + theme(legend.position = "none") 
```

### Word Count

How many words, on average, is each speaker using in a sentence?

```{r message=FALSE, warning=FALSE}
ggplot(data_with_pol, aes(x = Speaker, y = word_count, fill = Speaker)) + 
  stat_summary(fun = mean, geom = "bar", color = "black", alpha = 0.8, position = "dodge") +
    stat_summary(fun.data = mean_se, geom = "errorbar", fun.args = list(mult = 1.96), width = 0.3, color = "black") +
  scale_fill_manual(values = colors) +
  xlab("speaker") + ylab("average word count per sentence") + 
  theme_classic() + theme(legend.position = "none") 

```

### Sentiment density

What's the distribution of sentiment scores per person?

```{r message=FALSE, warning=FALSE}

ggplot(data_with_pol, aes(x=sentiment,color=Speaker)) + facet_wrap(vars(Speaker)) +
  geom_vline(xintercept=0, linetype='dashed', color='grey') +
  geom_density(aes(sentiment)) +
  scale_color_manual(values = colors) +
  theme_classic() + theme(legend.position = "none") 
 
```

# Social networks

One idea I have for the Survivor data is to see how similarly a social network created JUST using the number of spoken interactions between players is to a social network defined by participant responses (choosing friends, rivals, winners, etc.)

```{r message=FALSE, warning=FALSE}
# set options
options(stringsAsFactors = F)         # no automatic data transformation
options("scipen" = 100, "digits" = 4) # suppress math annotation
```

### Load Data

I want to create a network that shows how often people talk to each other in Survivor. I can do this by visualizing the network, defining my nodes (represented as dots) and my edges (represented as lines between dots).

In directed networks, the direction of edges can be captured and will have arrows to indicate direction. The thickness of lines can also be used to show information such as frequency. 

First, I want to count how often people talk to each other in the Survivor data, and reshape those counts into a co-occurrence matrix (showing how often two characters talk to each other for all characters). 

**These first figures include all contestants, the host, the camera, and the tribe as "speakers" and "recipients" (i.e. who is speaking and to whom).**

```{r message=FALSE, warning=FALSE}
# count number of times each speaker spoke to each recipient
new.speakers <- data %>%
  group_by(Speaker,Recipient) %>%
    summarize(SpeakerNumber = length(Speaker))

# remove Probst as a speaker for now & remove camera as recipient
# speakers <- subset(new.speakers, Speaker != "Probst")
# speakers <- subset(speakers, Recipient != "Camera")

speaker.count <- new.speakers$SpeakerNumber

speakers <- expandRows(new.speakers, count = speaker.count ,count.is.col = FALSE, drop = FALSE)

# reshape data 
test <- speakers[,1:2] #take only speaker and recipient info
test <- dcast(test,Speaker~Recipient) #reshape from long data into wide data format
rownames(test) <- test[,1] #make rownames the name of SPEAKER
test <- test[,-1] #remove speaker names from DF

# create co-occurrence matrix
speakers <- as.matrix(test)
out <- crossprod(speakers)  # Same as: t(X) %*% X
diag(out) <- 0       # (b/c you don't count co-occurrences of an aspect with itself)
speakers <- data.frame(speakers)

## ROW NAMES ARE SPEAKERS! ##

# add in speakers and recipients who never co-occur (i.e., never talk to each other)
Camera <- c(0,0,0,0,0,0,0,0,0,0)
Tribe <- c(0,0,0,0,0,0,0,0,0,0)

speakers <- rbind(speakers,Camera,Tribe)
row.names(speakers)[9] <- "Camera"
row.names(speakers)[10] <- "Tribe"

```

First, I'll define the nodes and edges. The nodes will represent people and the edges represent spoken interactions between people. Right now, the edges are non-directional, meaning they don't show who the speaker is or who the recipient is. They just show an interaction between individuals (or the group).

```{r message=FALSE, warning=FALSE}
# define speaker nodes using co-occurrence matrix
va <- speakers %>%
  dplyr::mutate(Speaker = rownames(.),
                Occurrences = rowSums(.)) %>%
  dplyr::select(Speaker, Occurrences)

ed <- speakers %>%
  dplyr::mutate(from = rownames(.)) %>%
  tidyr::gather(to, Frequency, Alicia:Tribe) %>%
  dplyr::mutate(Frequency = ifelse(Frequency == 0, NA, Frequency))
```

Once I have generated tables for nodes and edges, I can generate a graph object and add labels to my nodes.

```{r message=FALSE, warning=FALSE}
ig <- igraph::graph_from_data_frame(d=ed, vertices=va$vertices, directed = TRUE)

tg <- tidygraph::as_tbl_graph(ig) %>% 
  tidygraph::activate(nodes) %>% 
  dplyr::mutate(label=name)

# set seed
set.seed(12345)
# edge size shows frequency of co-occurrence
tg %>%
   ggraph(layout = "fr") +
   geom_edge_arc(colour= "gray50",
                 lineend = "round",
                 strength = .1,
                 alpha = .1) +
   geom_node_text(aes(label = name),
                  repel = TRUE,
                  point.padding = unit(0.2, "lines"),
                  colour="gray10") +
  theme_graph(background = "white") +
  guides(edge_width = FALSE,
         edge_alpha = FALSE)

v.size <- va$Occurrences

```

I can modify the edges to show the frequency by increasing and decreasing the thickness of one edge to show the frequency of interactions - the more two people talk to each other, the thicker the edge will be.

I can also modify my node size. Now, the node size is indicative of how often the person speaks (bigger node = speaks more).

```{r message=FALSE, warning=FALSE}
E(tg)$weight <- E(tg)$Frequency

# set seed
set.seed(12345)
# edge size shows frequency of co-occurrence
tg %>%
   ggraph(layout = "fr") +
   geom_edge_arc(colour= "gray80",
                  lineend = "round",
                 strength = .1,
                 aes(edge_width = weight,
                     alpha = weight)) +
   geom_node_point(size=v.size*.15,
                   color = colors) + 
   geom_node_text(aes(label = name), 
                  repel = TRUE, 
                  point.padding = unit(0.4, "lines"), 
                  size=4, 
                  colour="gray10") +
  scale_edge_width(range = c(0, 2.5)) +
  theme_graph(background = "white") +
  theme(legend.position = "top") +
  guides(edge_width = FALSE,
         edge_alpha = FALSE)
```

I can also show directionality by adding arrows to each edge. 

```{r warning=FALSE, message=FALSE}
E(tg)$weight <- E(tg)$Frequency

# set seed
set.seed(12345)
# edge size shows frequency of co-occurrence
tg %>%
   ggraph(layout = "fr") +
   geom_edge_arc(colour= "grey80",
                 lineend = "round",
                 arrow = arrow(angle = 30,length=unit(0.5,"cm")),
                 repel = TRUE,
                 strength = .1,
                 aes(edge_width = weight,
                     alpha = weight)) +
   geom_node_point(size=v.size*.15,
                   repel = TRUE,
                   point.padding = unit(1.5, "inches"),
                   color = colors) + 
   geom_node_text(aes(label = name), 
                  repel = TRUE, 
                  point.padding = unit(1.5, "inches"), 
                  size=4, 
                  colour="gray10") +
  scale_edge_width(range = c(0, 2.5)) +
  theme_graph(background = "white") +
  theme(legend.position = "top") +
  guides(edge_width = FALSE,
         edge_alpha = FALSE)
```

#### Now only include contestants

Previously, I was including all interactions (talking to host, camera, and whole tribe). Now, what does the network look like for contestants ONLY?

```{r warning=FALSE, message=FALSE}
# remove camera, tribe, and probst from co-occurrence matrix
contestants <- subset(speakers, select = -c(Camera,Probst,Tribe))
rows_to_remove <- c("Camera","Probst","Tribe")
contestants <- contestants[!(row.names(contestants) %in% rows_to_remove),]

# define speaker nodes using co-occurrence matrix
va <- contestants %>%
  dplyr::mutate(Speaker = rownames(.),
                Occurrences = rowSums(.)) %>%
  dplyr::select(Speaker, Occurrences)

# define edges
ed <- contestants %>%
  dplyr::mutate(from = rownames(.)) %>%
  tidyr::gather(to, Frequency, Alicia:Tom) %>%
  dplyr::mutate(Frequency = ifelse(Frequency == 0, NA, Frequency))

ig <- igraph::graph_from_data_frame(d=ed, vertices=va$vertices, directed = TRUE)

tg <- tidygraph::as_tbl_graph(ig) %>% 
  tidygraph::activate(nodes) %>% 
  dplyr::mutate(label=name)

# set seed
set.seed(12345)

E(tg)$weight <- E(tg)$Frequency

#contestant.colors <- met.brewer("Hiroshige",7,type="discrete")
contestant.colors <- colors[c(1,2,3,5,6,7,8)] 

v.size.contestants <- va$Occurrences

# set seed
set.seed(12345)
# edge size shows frequency of co-occurrence
tg %>%
   ggraph(layout = "fr") +
   geom_edge_arc(colour= "grey80",
                 lineend = "round",
                 arrow = arrow(angle = 30,length=unit(0.5,"cm")),
                 repel = TRUE,
                 strength = .1,
                 aes(edge_width = weight,
                     alpha = weight)) +
   geom_node_point(size=v.size.contestants*.3,
                   repel = TRUE,
                   point.padding = unit(1.5, "inches"),
                   color = contestant.colors) + 
   geom_node_text(aes(label = name), 
                  repel = TRUE, 
                  point.padding = unit(1.5, "inches"), 
                  size=4, 
                  colour="gray10") +
  scale_edge_width(range = c(0, 2.5)) +
  theme_graph(background = "white") +
  theme(legend.position = "top") +
  guides(edge_width = FALSE,
         edge_alpha = FALSE)

```




