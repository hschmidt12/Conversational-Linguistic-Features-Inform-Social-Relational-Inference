---
title: "Survivor - Sentiment Analysis"
author: "Helen Schmidt"
date: "`r Sys.Date()`"
output:
  html_document:
    df_print: paged
    theme: cerulean
    toc: true
    toc_float: true
    code_folding: hide
    number_sections: false
---
<style>
h1, h2, h3, h4, h5, h6, legend {
    color: #046C9A;
}
</style>

***

The goal of this markdown is to see to what extent sentiment is correlated with choices about friendship, rivalry, and likelihood to win between contestants on Survivor. Using the dialogue from the episode as well as the choices participants made about friendship, rivalry, and likelihood to win, I will a) see if sentiment correlates with responses and b) see if I can train a classifier to predict choices based on sentiment.

I don't include any dialogue spoken by the host in these analyses. **Only dialogue spoken by contestants is included**, even if it's to the camera, to the host, or to the tribe as a whole.

```{r message=FALSE, warning=FALSE}
library(tidyverse)
library(tidytext)
library(dplyr)
library(knitr)
library(readr)
library(wordcloud)
library(wordcloud2)
library(RColorBrewer)
library(tm)
library(SnowballC)
library(XML)
library(RCurl)
library(ggpubr)
library(wesanderson)
library(reshape2)
library(MetBrewer)
library(sentimentr)
library(sna)
library(splitstackshape)
library(GGally)
library(ggraph)
library(gutenbergr)
library(igraph)
library(Matrix)
library(network)
library(tidygraph)
library(tibble)
library(formattable)
library(forcats)
library(devtools)
devtools::install_github("strengejacke/sjPlot")

se <- function(x) sqrt(var(x)/length(x))  #function to calculate SE

```

```{r message=FALSE, warning=FALSE}
# define color palette
colors <- met.brewer("Hiroshige", 7, type = "discrete")
palette <- met.brewer("Hiroshige", 25, type = "continuous")

customGreen = "#71CA97"
customRed = "#ff7f7f"

improvement_formatter <- 
  formatter("span", 
            style = x ~ style(
              font.weight = "bold", 
              color = ifelse(x > 0, customGreen, ifelse(x < 0, customRed, "black"))))

## ----- LOAD TEXT DATA ----- ##
text.data <- read.csv("survivor-text.csv")
# make sure dialogue is a character vector
text.data$Dialogue <- as.character(text.data$Dialogue)
# make speaker, recipient, and recipient type character vectors too
text.data$Speaker <- as.character(text.data$Speaker)
text.data$Recipient <- as.character(text.data$Recipient)
text.data$RecipientType <- as.character(text.data$RecipientType)
# remove space from Shii Ann's name for ease of plotting
text.data$Speaker[text.data$Speaker == "Shii Ann"] = "ShiiAnn"
text.data$Recipient[text.data$Recipient == "Shii Ann"] = "ShiiAnn"
# make sure recipient type matches recipient
text.data$RecipientType <- "Person"
text.data$RecipientType[text.data$Recipient == "Tribe"] = "Group"
text.data$RecipientType[text.data$Recipient == "Camera"] = "Camera"
# remove Probst as a speaker
text.data <- subset(text.data, text.data$Speaker != "Probst")

## ----- LOAD CHOICE DATA ----- ##
choice.data <- read.csv("dat_survivor.csv")
# capitalize first names
capFirst <- function(s) {paste(toupper(substring(s, 1, 1)), substring(s, 2), sep = "")}
choice.data$Target <- capFirst(choice.data$Target)
choice.data$LeftPersonImg <- capFirst(choice.data$LeftPersonImg)
choice.data$RightPersonImg <- capFirst(choice.data$RightPersonImg)
choice.data$choice <- capFirst(choice.data$choice)
# make Shii Ann's name consistent with text.data
choice.data[choice.data == "Shiiann"] = "ShiiAnn"
# rename clips to match text.data
names(choice.data)[8] <- "ClipNumber"

## ----- SEPARATE CHOICE CATEGORIES ----- ##
friend.data <- subset(choice.data, choice.data$condType == "Friend")
win.data <- subset(choice.data, choice.data$condType == "Win")
rival.data <- subset(choice.data, choice.data$condType == "Rival")
```

### Sentiment scores

**What do the two tables below tell me?**

In the first table, I'm assigning a **sentiment score** to every sentence. 

**element_id** -- refers to each cell containing dialogue (may contain one or many sentences) 

**sentence_id** -- refers to each sentence in one cell containing dialogue

**word_count** -- refers to the number of words in each sentence 

**sentiment** -- sentiment score assigned to the sentence

```{r message=FALSE, warning=FALSE}
sentiment(text.data$Dialogue)
```

In the second table (Table 2), I'm calculating the **mean sentiment score** and **SD** for each cell of dialogue. This is important because each cell refers to an interaction (with a given speaker and recipient of that dialogue). **element_id** and **word_count** mean the same as the first table. 

**sd** -- standard deviation of the average sentiment score (for all sentences in that cell, referring to the element_id)

**ave_sentiment** -- mean sentiment score for each cell of dialogue 

```{r message=FALSE, warning=FALSE}
sentiment_by(text.data$Dialogue, by = NULL)

# add polarity levels for each sentence
data_with_pol <- text.data %>% 
  get_sentences() %>% #get each sentence
  sentiment() %>% #get sentiment score
  #make scores < 0 "negative" and scores > 0 "positive"
  mutate(polarity_level = ifelse(sentiment < 0, "Negative", 
                                 #else, make scores = 0 "neutral"
                                 ifelse(sentiment > 0, "Positive","Neutral"))) 
```

***

#### Mean sentiment score per speaker

Let's see what each speaker's average sentiment score is!

```{r message=FALSE, warning=FALSE}
ggplot(data_with_pol, aes(x = Speaker, y = sentiment, fill = Speaker)) + 
  stat_summary(fun = mean, geom = "bar", color = "black", alpha = 0.8, position = "dodge") +
    stat_summary(fun.data = mean_se, geom = "errorbar", fun.args = list(mult = 1.96), width = 0.3, color = "black") +
  scale_fill_manual(values = colors) +
  xlab("speaker") + ylab("average sentiment") + 
  theme_classic() + theme(legend.position = "none") 
```

#### What about per episode clip?

```{r message=FALSE, warning=FALSE, fig.height=12}
ggplot(data_with_pol, aes(x = Speaker, y = sentiment, fill = Speaker)) + 
  facet_grid(vars(ClipNumber)) +
  stat_summary(fun = mean, geom = "bar", color = "black", alpha = 0.8, position = "dodge") +
  stat_summary(fun.data = mean_se, geom = "errorbar", fun.args = list(mult = 1.96), width = 0.3, color = "black") +
  scale_fill_manual(values = colors) +
  xlab("speaker") + ylab("average sentiment") + 
  theme_classic() + theme(legend.position = "none") 
```

***

#### Speaker's sentiment towards recipient

Now I want to examine average sentiment that a speaker has toward the recipient. To do this, I will look at average sentiment scores when every speaker is talking to every recipient.

```{r message=FALSE, warning=FALSE, fig.height=12}

ggplot(data_with_pol, aes(x = Recipient, y = sentiment, fill = Speaker)) + facet_grid(vars(Speaker)) +
  stat_summary(fun = mean, geom = "bar", color = "black", alpha = 0.8, position = "dodge") +
    stat_summary(fun.data = mean_se, geom = "errorbar", fun.args = list(mult = 1.96), width = 0.3, color = "black") + 
  scale_fill_manual(values = colors) +
  xlab("recipient") + ylab("average sentiment") + 
  theme_classic() + theme(legend.position = "none") 

speakers <- data_with_pol %>%
  group_by(Speaker,Recipient) %>%
    summarize(avg_Recipient_Sentiment = mean(sentiment))

formattable(speakers, list(`avg_Recipient_Sentiment` = improvement_formatter))
```

***

### Correlations

#### Sentiment Scores & Friendship Choices

Now I want to correlate **sentiment scores** and **friendship choices**. To do this, I'm using each target's average sentiment score across the whole episode and correlating that score with the % time each contestant is chosen as being friends with that target (ex. if Rob is the target, what % of time is Alicia chosen as a friend when she's presented as an option?). Each target will have one sentiment score for the whole episode and a % choice value for each other contestant.

Each point represents one choice

```{r message=FALSE, warning=FALSE}
# format text data! (data_with_pol)
sentiment.data <- data_with_pol %>%
  group_by(Speaker) %>%
    summarize(TargetAvgSentiment = mean(sentiment))

# rename speaker to target match choice data
names(sentiment.data)[1] <- "Target"

# format choice data - only friend condition
decision.data <- subset(choice.data, choice.data$condType == "Friend")

unique.targets <- unique(decision.data$Target)
unique.choices <- unique(decision.data$choice)

formatted.choices <- data.frame()
# calculate % time chosen
for (x in 1:length(unique(decision.data$Target))) {
  all.choices <- data.frame()
  # subset to one target only
  test <- subset(decision.data, decision.data$Target == unique.targets[x])
  # loop through possible choices
  for (y in 1:length(unique(decision.data$choice))) {
    # how many times was each person an option?
    choices <- subset(test, c(test$LeftPersonImg == unique.choices[y] | test$RightPersonImg == unique.choices[y]))
    # group by sub ID, count the number of times someone appears as a choice vs % time chosen
    choices <- choices %>%
      group_by(PID,Target) %>%
        mutate(n = str_count(choice, unique.choices[y])) %>%
          summarize(option = length(Target),
                    selected = sum(n))
    # add in choice name
    choices$choice <- unique.choices[y]
    # calculate percent of time chosen
    choices <- choices %>%
      group_by(PID,Target,choice) %>%
        summarize(percent.chosen = selected/option)
    # save choices into new data frame
    all.choices <- rbind(all.choices, choices)
  }
  # save all targets into new data frame
  formatted.choices <- rbind(formatted.choices, all.choices)
}

# merge data frames
correlation.data <- merge(formatted.choices, sentiment.data, by = "Target")

## ^ could also do difference in avg. sentiment between each target and choice

# average across participants for plotting
plot.correlations <- correlation.data %>%
  group_by(Target,choice) %>%
    summarize(mean.TargetSentiment = mean(TargetAvgSentiment),
              mean.percentChosen = mean(percent.chosen))

# plot!
ggplot(plot.correlations, aes(x=mean.TargetSentiment, y=mean.percentChosen, color = choice)) + 
  geom_point(size=2) + scale_color_manual(values = colors) +
  theme_classic() + xlab("target's avg. sentiment score") + ylab("% time chosen as friend of target")

# correlate avg. sentiment scores with percent of time chosen as friend
corValue <- cor(plot.correlations$mean.TargetSentiment, plot.correlations$mean.percentChosen, method = "pearson")
print(paste('r =', corValue, sep = " "))

# order x axis by avg sentiment score
ggplot(correlation.data, aes(x = fct_reorder(Target, TargetAvgSentiment), y = percent.chosen, fill = choice, group = choice)) + 
  stat_summary(fun = mean, geom = "bar", color = "black", alpha = 0.8, position = "dodge", width = 0.9) +
  stat_summary(fun.data = mean_se, geom = "errorbar", fun.args = list(mult = 1.96), width = 0.3, color = "black", position = position_dodge(0.9)) +
  scale_fill_manual(values = colors) +
  xlab("target (increasing avg. sentiment scores L > R)") + ylab("% chosen as friend of target") + 
  theme_classic() 

```

#### Sentiment Scores & Rivalry Choices

```{r message=FALSE, warning=FALSE}
# format text data! (data_with_pol)
sentiment.data <- data_with_pol %>%
  group_by(Speaker) %>%
    summarize(TargetAvgSentiment = mean(sentiment))

# rename speaker to target match choice data
names(sentiment.data)[1] <- "Target"

# format choice data - only friend condition
decision.data <- subset(choice.data, choice.data$condType == "Rival")

unique.targets <- unique(decision.data$Target)
unique.choices <- unique(decision.data$choice)

formatted.choices <- data.frame()
# calculate % time chosen
for (x in 1:length(unique(decision.data$Target))) {
  all.choices <- data.frame()
  # subset to one target only
  test <- subset(decision.data, decision.data$Target == unique.targets[x])
  # loop through possible choices
  for (y in 1:length(unique(decision.data$choice))) {
    # how many times was each person an option?
    choices <- subset(test, c(test$LeftPersonImg == unique.choices[y] | test$RightPersonImg == unique.choices[y]))
    # group by sub ID, count the number of times someone appears as a choice vs % time chosen
    choices <- choices %>%
      group_by(PID,Target) %>%
        mutate(n = str_count(choice, unique.choices[y])) %>%
          summarize(option = length(Target),
                    selected = sum(n))
    # add in choice name
    choices$choice <- unique.choices[y]
    # calculate percent of time chosen
    choices <- choices %>%
      group_by(PID,Target,choice) %>%
        summarize(percent.chosen = selected/option)
    # save choices into new data frame
    all.choices <- rbind(all.choices, choices)
  }
  # save all targets into new data frame
  formatted.choices <- rbind(formatted.choices, all.choices)
}

# merge data frames
correlation.data <- merge(formatted.choices, sentiment.data, by = "Target")

# average across participants for plotting
plot.correlations <- correlation.data %>%
  group_by(Target,choice) %>%
    summarize(mean.TargetSentiment = mean(TargetAvgSentiment),
              mean.percentChosen = mean(percent.chosen))

ggplot(plot.correlations, aes(x=mean.TargetSentiment, y=mean.percentChosen, color = choice)) + 
  geom_point(size=2) + scale_color_manual(values = colors) +
  theme_classic() + xlab("avg. sentiment score for speaker") + ylab("% time chosen as rival")

# correlate avg. sentiment scores with percent of time chosen as friend
corValue <- cor(correlation.data$TargetAvgSentiment, correlation.data$percent.chosen, method = "pearson")
print(paste('r =', corValue, sep = " "))

# order x axis by avg sentiment score
ggplot(correlation.data, aes(x = fct_reorder(Target, TargetAvgSentiment), y = percent.chosen, fill = choice, group = choice)) + 
stat_summary(fun = mean, geom = "bar", color = "black", alpha = 0.8, position = "dodge", width = 0.9) +
stat_summary(fun.data = mean_se, geom = "errorbar", fun.args = list(mult = 1.96), width = 0.3, color = "black", position = position_dodge(0.9)) +
scale_fill_manual(values = colors) +
xlab("target (increasing avg. sentiment scores L > R)") + ylab("% chosen as rival of target") + 
theme_classic() 
```

***

#### Last sentiment before choice

Now, rather than take each speaker's average sentiment over the whole episode, I'm going to compare % choice of friendship for each contestant to the sentiment score from the most recent dialogue. Participants make their choices at the end of each clip (1-6), so I'm going to pull each speaker's last sentiment score before the participant choice.

```{r message=FALSE, warning=FALSE}
# format text data
sentiment.data <- data_with_pol %>%
  group_by(Speaker,ClipNumber) %>%
    mutate(last.dialogue = max(element_id))

sentiment.data <- sentiment.data %>%
  group_by(Speaker,last.dialogue,element_id,ClipNumber) %>%
    summarize(dialogue = Dialogue,
              sentiment.score = sentiment)

sentiment.data <- sentiment.data[sentiment.data$last.dialogue==sentiment.data$element_id, ]

# average sentiment scores for multiple elements
sentiment.data <- sentiment.data %>%
  group_by(Speaker,ClipNumber,last.dialogue) %>%
    summarize(avg.sentiment = mean(sentiment.score))

# rename speaker to target match choice data
names(sentiment.data)[1] <- "Target"

# format choice data - only friend condition
decision.data <- subset(choice.data, choice.data$condType == "Friend")

unique.targets <- unique(decision.data$Target)
unique.choices <- unique(decision.data$choice)

formatted.choices <- data.frame()
# calculate % time chosen
for (x in 1:length(unique(decision.data$Target))) {
  all.choices <- data.frame()
  # subset to one target only
  test <- subset(decision.data, decision.data$Target == unique.targets[x])
  # loop through possible choices
  for (y in 1:length(unique(decision.data$choice))) {
    # how many times was each person an option?
    choices <- subset(test, c(test$LeftPersonImg == unique.choices[y] | test$RightPersonImg == unique.choices[y]))
    # group by sub ID, count the number of times someone appears as a choice vs % time chosen
    choices <- choices %>%
      group_by(PID,Target,ClipNumber) %>%
        mutate(n = str_count(choice, unique.choices[y])) %>%
          summarize(option = length(Target),
                    selected = sum(n))
    # add in choice name
    choices$choice <- unique.choices[y]
    # calculate percent of time chosen
    choices <- choices %>%
      group_by(PID,Target,choice,ClipNumber) %>%
        summarize(percent.chosen = selected/option)
    # save choices into new data frame
    all.choices <- rbind(all.choices, choices)
  }
  # save all targets into new data frame
  formatted.choices <- rbind(formatted.choices, all.choices)
}

# merge data frames
correlation.data <- merge(formatted.choices, sentiment.data, by = c("Target","ClipNumber"))

ggplot(correlation.data, aes(x=avg.sentiment, y=percent.chosen, color = choice)) + 
  geom_point(size=2) +
  theme_classic() + xlab("avg. sentiment score for speaker") + ylab("% time chosen as friend")

# correlate avg. sentiment scores with percent of time chosen as friend
corValue <- cor(correlation.data$avg.sentiment, correlation.data$percent.chosen, method = "pearson")
print(paste('r =', corValue, sep = " "))

```
